generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

/**
 * Колонки канбана. Колонки уникальны в рамках chatId по ИМЕНИ.
 * Внутри каждой группы имена с префиксом groupId::...
 */
model Column {
  id        String   @id @default(cuid())
  chatId    String
  name      String
  order     Int
  tasks     Task[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([chatId, name])
  @@index([chatId])
}

/* -------------------- NEW/UPDATED ENUMS -------------------- */

enum TaskType {
  TASK
  EVENT
}

enum EventRole {
  ORGANIZER
  PARTICIPANT
}

/* -------------------- TASKS -------------------- */
/**
 * Задачи.
 * Теперь поддерживает типы: обычная задача (TASK) и мероприятие (EVENT).
 * Для EVENT используем startAt/endAt, участников и отдельные инвайты.
 */
model Task {
  id          String   @id @default(cuid())

  chatId      String
  text        String
  order       Int
  tgMessageId String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  columnId String
  column   Column @relation(fields: [columnId], references: [id], onDelete: Cascade)

  assigneeChatId String?

  // === NEW: тип задачи/события + даты (для EVENT)
  type     TaskType @default(TASK)
  startAt  DateTime?
  endAt    DateTime?

  // Инвайты на TASK (как было)
  inviteTickets       InviteTicket[] @relation("TaskInviteTickets")
  // NEW: инвайты на EVENT (отдельная связь на тот же Task, когда type=EVENT)
  eventInviteTickets  InviteTicket[] @relation("EventInviteTickets")

  // NEW: участники мероприятия (только для EVENT, но связь не мешает TASK)
  participants EventParticipant[]

  @@index([chatId])
  @@index([columnId, order])

  sourceChatId     String?  // куда отправили исходное уведомление
  sourceMessageId  Int?     // message_id исходного уведомления

   reminders    EventReminder[]   // one-to-many: Task -> EventReminder

  comments  Comment[]
}

/* -------------------- GROUPS -------------------- */

model Group {
  id          String   @id @default(cuid())
  ownerChatId String
  title       String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  members       GroupMember[]
  shortcuts     GroupShortcut[]
  inviteTickets InviteTicket[]  @relation("GroupInviteTickets")

  @@unique([ownerChatId, title])
  @@index([ownerChatId])
}

model User {
  chatId    String   @id
  username  String?
  firstName String?
  lastName  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model GroupMember {
  id        String   @id @default(cuid())
  groupId   String
  chatId    String
  role      String   @default("member")
  createdAt DateTime @default(now())

  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([groupId, chatId])
  @@index([chatId])
}

/**
 * Короткие коды для выбора группы через /g_1, /g_2, ...
 * Код уникален в рамках чата; у каждой группы в чате — не более одного кода.
 */
model GroupShortcut {
  id        String   @id @default(cuid())
  chatId    String
  groupId   String
  code      String
  createdAt DateTime @default(now())

  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([chatId, code])
  @@unique([chatId, groupId])
  @@index([chatId])
  @@index([groupId])
}

/* -------------------- NOTIFICATIONS / COMMENTS -------------------- */

model NotificationSetting {
  telegramId               String   @id
  receiveTaskAccepted      Boolean  @default(true)
  writeAccessGranted       Boolean  @default(false)
  receiveTaskCompletedMine Boolean  @default(true)
  updatedAt                DateTime @updatedAt
  receiveTaskComment       Boolean  @default(true)
}

model Comment {
  id            String   @id @default(cuid())
  taskId        String
  task          Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  authorChatId  String
  text          String
  createdAt     DateTime @default(now())
}

/* -------------------- LEGACY INVITE (оставляем как было) -------------------- */

model Invite {
  id         String   @id @default(cuid())
  type       String   // 'TASK'
  mode       String   // 'assign'
  token      String   @unique
  taskId     String
  createdBy  String?
  usedAt     DateTime?
  createdAt  DateTime @default(now())
}

/* -------------------- INVITE TICKETS (расширены под EVENT) -------------------- */

model InviteTicket {
  id     String       @id @default(cuid())
  token  String       @unique
  type   InviteType
  status InviteStatus @default(ACTIVE)

  groupId         String
  taskId          String?
  invitedByChatId String
  createdAt       DateTime  @default(now())
  expiresAt       DateTime?

  // === NEW: для EVENT — ссылка на Task с type=EVENT
  eventId String?
  event   Task?   @relation("EventInviteTickets", fields: [eventId], references: [id])

  // === именованные связи (как были)
  group Group @relation("GroupInviteTickets", fields: [groupId], references: [id], onDelete: Cascade)
  task  Task? @relation("TaskInviteTickets", fields: [taskId], references: [id], onDelete: SetNull)

  @@index([groupId])
  @@index([taskId])
  @@index([eventId])
}

enum InviteType {
  TASK
  GROUP
  EVENT
}

enum InviteStatus {
  ACTIVE
  USED
  EXPIRED
}



enum ProcessNodeType {
  TASK
  EVENT
}

enum StartMode {
  AFTER_ANY
  AFTER_SELECTED
  AT_DATE
  AT_DATE_AND_SELECTED
  AFTER_DAYS_AND_SELECTED
}

enum CancelMode {
  NONE
  IF_ANY_SELECTED_CANCELED
}




/* -------------------- NEW: УЧАСТНИКИ СОБЫТИЯ -------------------- */

model EventParticipant {
  id       String    @id @default(cuid())
  eventId  String
  event    Task      @relation(fields: [eventId], references: [id], onDelete: Cascade)

  chatId   String
  role     EventRole @default(PARTICIPANT)

  createdAt DateTime @default(now())

  @@unique([eventId, chatId])  // один участник один раз в событии
  @@index([chatId])
}



model EventReminder {
  id              String   @id @default(cuid())
  eventId         String
  event           Task     @relation(fields: [eventId], references: [id], onDelete: Cascade)

  chatId          String            // участник, кому слать
  offsetMinutes   Int               // 60, 10, 5
  fireAt          DateTime          // когда именно слать (startAt - offset)
  replyToMessageId Int?             // message_id базового сообщения про событие (для reply)
  sentAt          DateTime?
  tries           Int      @default(0)
  createdAt       DateTime @default(now())

  @@unique([eventId, chatId, offsetMinutes]) // по одному напоминанию каждого вида на участника
  @@index([fireAt])
  @@index([eventId, chatId])
}



/// ==== Процессы (минимально, без FK на текущие модели) ====

model GroupProcess {
  id            String   @id @default(cuid())
  groupId       String   // ID существующей группы (пока без relation, привяжем позже)
  title         String?  // заголовок процесса (необязателен)
  runMode       String   @default("MANUAL") // MANUAL | SCHEDULE
  scheduleRRule String?  // RRULE, если runMode=SCHEDULE
  timezone      String?  // например, "Europe/Moscow"
  isActive      Boolean  @default(true)
  createdBy     String   // chatId создателя
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model ProcessNode {
  id               String   @id @default(cuid())
  processId        String
  title            String
  posX             Float    @default(0)
  posY             Float    @default(0)

  // жизненный цикл узла
  status           String   @default("PLANNED")
  type             ProcessNodeType @default(TASK)

  // роли
  assigneeChatId   String?
  createdByChatId  String?

  // условия запуска
  startMode        StartMode  @default(AFTER_ANY)
  startDate        DateTime?
  startAfterDays   Int?

  // условия отмены
  cancelMode       CancelMode @default(NONE)

  // связь с реальной задачей (когда узел породил Task)
  taskId           String?
  // если хочешь — можно сделать relation: task Task? @relation(fields: [taskId], references: [id])

  // расширяемый карман
  metaJson         Json?

  // наблюдатели
  watchers         ProcessNodeWatcher[]

  createdAt        DateTime @default(now())
}


model ProcessEdge {
  id           String @id @default(cuid())
  processId    String
  sourceNodeId String
  targetNodeId String
  enabled      Boolean @default(true)
}




model ProcessNodeWatcher {
  id      String @id @default(cuid())
  nodeId  String
  chatId  String

  node    ProcessNode @relation(fields: [nodeId], references: [id], onDelete: Cascade)

  @@unique([nodeId, chatId])
  @@index([chatId])
}









model ProcessRun {
  id         String   @id @default(cuid())
  processId  String   // GroupProcess.id
  startedAt  DateTime @default(now())
  startedBy  String   // chatId, кто запустил
  status     String   @default("RUNNING") // RUNNING | COMPLETED | CANCELED
  note       String?
}

model RunTask {
  id                String   @id @default(cuid())
  runId             String   // ProcessRun.id
  nodeId            String   // ProcessNode.id
  taskId            String?  // ID задачи (свяжем позже, когда создадим реальную задачу)
  status            String   @default("PLANNED") // PLANNED | CREATED | IN_PROGRESS | DONE | CANCELED
  checklistMessageId String? // Telegram message id чек-листа
  checklistItemId    String?
  telegramChatId     String? // кому отправили чек-лист
  createdAt         DateTime @default(now())
  doneAt            DateTime?
}
